# R Programming Fundamentals



## Programming Preliminaries

```{block2, type="reflect"}

1. Look at a sentence in a language you don't know, look carefully at the symbols, spacing and characters. 
1. Recall learning a foreign language, how you had to learn the syntax and grammar rules.
1. Now think about English (or another language you know well) and think about the syntax and grammar rules that you take for granted. 

```

TODO: talk about syntax and grammar

All human languages rely on a set of rules called grammar, which describe how the language should be used to communicate.
When two humans communicate with a language, they both must agree on the the rules of that language.
R also has rules that must be followed in order for a human ( _you_ ) to communicate with a computer, in order to tell the computer what to do.
In human language, grammar is often fluid and evolving, and two people may have to adapt their use of the language in order to communicate.
With R, the fules are fixed, and the computer "knows" them perfectly.
Therefore it is up to you to learn the rules in order to make the computer do exactly what you want it to do.

Therefore it's important to cover some of the basic rules of the R programming language before you can learn all of the things R can do. 
So here they are:

### R Commands

Like most programming languages, R consists of a set of _commands_ which form the sequence of instructions which the computer completes. Here is an example of a command, followed by the result.

```{r}
print("hello, world!")
```

This command is telling R to print out a message.
R code usually contains more than one command, and typically each command is put on a separate line.
Here are multiple commands, each on a separate line:

```{r}
print("The air is fine!")
print(1+1)
print(4 > 5)
```

The first command prints another message, the second command does some math then then prints the result, and the third command evaluates whether the statement is true or false and prints the result. 
Generally, it's a good idea to put separate commands on separate lines, but you _can_ put multiple commands on the same line, __as long as you separate them by a semicolon__.
See this code for example:

```{r}
x <- 1+1; print(x); print(x^2)
```

In this example, three commands are given on one line.
The first command creates a new _variable_ called `x`, the second command prints the value of `x`, and the third command prints the value of `x` _squared_.
We see that the semicolon, `;`, serves as the command _termination_, because it tells R where one command ends and another begins.
When a line contains a single command, no semicolon in necessary at the end, but including a semicolon doesn't have any effect either.
```{r, class.source="chunk-style"}
print("This line doesn't have a semicolon")
print("This line does have a semicolon");
```
```{block, type="caution"}
Including multiple semicolons (e.g. `print("hello");;`) does not work!
```

```{block, type="bonus"}
You've just seen your first example of _assignment_.
That is, we created a thing called `x` , and _assigned_ to it the value of `1+1` using the _assignment operator_, `<-`.
Formally `x` is called an object, but we'll talk about that more objects and assignments later.
```


TODO: make these code blocks display on multiple lines:
```{block, type="bonus"}
So far, we've seen that you can place one command on one line, multiple commands on multiple lines, multiple commands on one line, so you may ask: can you can place one command on multiple lines?
The answer is _sometimes_, depending on the command.
Generally, if R is expecting the end of a command but doesn't see one by the time it gets to the end of a line, it will continue looking on the next line. 
Here are some examples:
`1 + \
1`

`
print("This string is on 
multiple lines")
`

```

```{block, type="caution"}
At this point, we've introduced several new types of R commands (assigning a variable, squaring a number, etc.), and we will talk more specifically about these later. The important part of this section is how R code is arranged into different _commands_
```

Lastly, commands can be "grouped together" using left and right curly braces: `{` and `}`.
Here's an example:

```{r}
{
  print("here's some code that's all grouped together")
  print(2^3 - 7)
  w <- "hello"
  print(w)
}
```

The above grouped code is indented so that it looks nice, but it doesn't have to be:

```{r}
{
print("here's some code that's all grouped together")
print(2^3 - 7)
w <- "hello"
print(w)
}
```

```{block, type="bonus"}
Indenting is an example of coding _style_, which are formatting decisions which don't affect the results of the code, but are meant to enhance readability.
We'll talk more about coding style later.
TODO: talk about style later.
In some programming languages, Python for example, white space matters. That is, code indents and other spaces change the way the code runs. In R, white space _does not_ matter, so things like indents are used purely for readability.
```

What does it mean to "group" code?
At this point there is no practical difference, each command gets executed whether or not it is grouped inside curly braces.
However, code grouping will become very important later on, when we discuss _control flow_ in section (TODO: add ref).

```{block, type="progress"}
In RStudio, open a new R script and type in all the R commands from this section, to verify that you get the same result. It's good practice!
```


### Comments

When writing R code, you may wish to include notes which explain the code to your future self or to other humans.
This can be done with _comments_, which are ignored by R when it is running the code. 
The "#" comment
Here's an example of some comments:

```{r}
# Let's define y and z
y <- 8
z <- y + 5 # adding 5 to y and assigning the result to z
## This is still a comment, even though we're using two #'s
```

Notice that it's possible for a line to contain only a comment, or for part of a line to be a comment. 
R decides which part of a line is a comment by looking for the first "#", and everything after that will be treated as a comment and ignored.



```{block, type="caution"}
R ignores comments, but you should _not_! If you're reading code that someone else has written, it's likely that also paying attention to their comments will greatly help you to understand what their code is doing. 
It's also courteous to make good comments in your own code, if only because you may have to return to your _own_ code in the future and re-learn what it is doing!
In this book, we will use comments to help explain the R code that you will see.
```


### Blank Lines

Blank lines in R are ignored, but they can be used to organize code and enhance readability:

```{r}
print("The sky is blue")
# the blank line below here is ignored

print("The grass is green")
```

### CaSe SeNsItIvItY

In R, variables, functions, and other objects (all of which we'll talk about later), have names.
These names are case sensitive, so you must be careful when referencing an object by name.
Here we create two variables and give them different values, notice how they are different from each other:

```{r}
A <- 4
a <- 5

print(a)
print(A)
```
This may seem obvious, but case sensitivity applies to functions (which we'll talk about later) too. 
We've been using the `print` function a lot in the above examples, which begins with a lower case p. 
There is no `Print` function:

```{r, error=TRUE}
Print("testing")
```

### ?
One _very_ nice thing in R is the documentation that accompanies it.
Every function included in R (like `print`) has documentation that explains how that function works.
To access the documentation, use a `?` followed by the name of the function, like so:

```{r, eval=FALSE}
?print
```

```{block, type="progress"}
The output of the above code chunk is not shown, because the result of this code is best viewed in RStudio. Go to R Studio and type in `?print` and observe what happens!
```

### ??

If you don't remember the exact name of a function, or would like to search for general matches to a topic, then you can use `??`.
For example, trying `?Print` produces an error, because there is not `Print` function (remember, R is case sensitive), so there's no documentation to go with it.
However, the following should still work:

```{r, eval=FALSE}
??Print
```

```{block, type="bonus"}
Programmers have a sense of humor, too! Try running `????print` to see a small joke. Remember, comedic taste varies!
```


TODO: put these bonus blocks in more appropriate places:
```{block, type="bonus"}
https://rstudio.com/wp-content/uploads/2016/10/r-cheat-sheet-3.pdf
```
```{block, type="bonus"}
Want to know more about R syntax? Try typing `?Syntax` in the R console (then press `Enter`).
```


```{block, type="caution"}
As we've seen, symbols and characters have specific meaning in R. You must be careful not to ignore things like semicolons, curly braces, parentheses, when reading R code. This takes practice!
```

Okay, now that we've covered some of the basics, it's time to start learning how to do useful things in R!
The next few sections will describe the different types of data that R can handle.

## Data Types

```{block, type="reflection"}
TODO: what should this be?
```


R can store and manipulate different pieces of information, called data, and these data can be of several different types.
Here are some examples of different types of data:

```{r}
a <- 12.34      # a is a number
b <- "Hello"    # b is a string of characters
c <- TRUE       # c is a special type of data that is either true or false
```

R has special names for these examples, and there are other types of data as well.
Below, we'll talk about each data type, one at a time.

```{block, type="bonus"}
The term "data" is actually plural! A single piece of data is called a "datum". So to refer to a set of data, you would say "these data", and to refer to a single piece of data, you would say "this datum".
```

### Numeric

Many data exist as numbers, and R has a specific data type for storing those numbers, called the _numeric_ data type. 
Here are some examples:

```{r}
a <- -11
b <- 13.37
c <- 1/137
```

Note that integers, decimals, and fractions are all examples of numeric data in R.
We can prove that these are all the same data type using the `class` function:

```{r}
class(a)
```
```{r}
class(b)
```
```{r}
class(c)
```

```{block, type="caution"}
So far, we've defined the `a` object a few different times, which is allowed!
Every time we define `a`, R _forgets_ the old value.
Therefore we should reuse object names with caution, because it can become difficult to remember what the _latest_ value is!
When we discuss _loops_ later, however, we will use code to automatically change the value of an object several times in order to do useful things!
```


When you have numeric objects, you may want to perform math operations on them.
R has a number of built in functions to deal with numeric data, here are some examples:

```{r}
print(a + b)  # Add two numeric values
print(b - c)  # subtract two numeric values 
print(a * b)  # multiply two numeric values
print(a^3)    # take the cube of a numeric value
```

When performing math on numeric objects, R will obey [order of operations](https://en.wikipedia.org/wiki/Order_of_operations), so the following two examples will give different results:

```{r}
a + b * c    # R will perform the multiplication before the addition
```
```{r}
(a + b) * c  # R will perform the addition first, then the multiplication 
```

Notice that we've added extra spaces in the code to help you understand what's going on.
This is another example of code _style_, which we'll talk more about later.

```{block, type="caution"}
Wait a second, we didn't use the the `print` function just now, but R still displayed the results of the calculations! 
What is going on?
This behavior is peculiar to something called R Markdown, which is what we used to create this book (yes, this book was creating using R! Pretty cool, huh?).
If the _last_ command given in a code block produces a result, and you don't assign that result to anything (using `<-`), then R will print out that result.
This means we don't always have to use the print function when we want to display R output.
```

Notice all the decimal points?
R can be very precise when performing computations.
However, viewing all of the digits stored by R can be distracting and hard to read.
You can show just some of the digits by using the `round` function:

```{r}
a
```

```{r}
round(a, 3)
```
It also turns out that R stores _more_ digits than what it shows when it prints, though we won't go into detail on that now.

TODO: talk about Inf, -Inf, and NaN?

### Integer

In general, numeric data in R are treated as if they can be any decimal number (technically, they are a _double precision_ number, if you know what that means; if not, it's not important right now).
However, there is a way to specify that a specific numeric object is an integer, by placing an "L" at the end of it, like so:
```{r}
x <- 20   # x will be a numeric object
y <- 20L  # y will be an integer object
```
```{r}
class(x)
```
```{r}
class(y)
```
Integers take half of the space in a computer's memory or hard drive, so if you are working with or storing a lot of numbers which are integers, it might make sense to declare them as integer type in R.
This will make more sense when we discuss vectors later.


### Character

Not all data are numbers! 
R also has the capability to store strings of characters, and this is the aptly named _character_ type (or sometimes called a _character string_ or just _string_).
Here are some examples:
```{r}
d <- "Hello"         # This string is defined with   *double*   quotes 
e <- 'how are you?'  # This string is defined with   *single*   quotes!
print(d)
print(e)
```

Notice how we can define character strings using single quotes or double quotes, as long as we are consistent. 
So this is not valid:

```{r, error=TRUE}
# Note the mismatched single/double quotes:
f <- "this does not work' 
```
So, make sure you are consistent. 
However, you may see another problem with this: some strings contain quotes _in them_, like this:

```{r, error=TRUE}
g <- 'This won't work'
```
Since single quotes are being used to define the string, they can't be used in the string itself, because R will "think" the string is ending at the second `'`.
One option is to change the defining quotes to be double quotes, then the single quote will be safely included in the string:

```{r}
g <- "I'm happy that this works!"
print(g)
```
Another option is to use a backslash when using quotes inside the string, so that R "knows" the quote is part of the string and not ending the definition of the string:

```{r}
g <- 'I\'ve found another way that works!'
print(g)
```

Notice that when we define `g` we place a `\'` anywhere in the string where we want a `'` to be, but when printed out, we see that R has interpreted it as just a `'`. 
Notice also that we didn't have to change the defining quotes to be double quotes in this case.
The backslash is called the _escape character_, and it signifies that what follows it should be interpreted _literally_ by R, and any special meaning should be ignored. 

```{block, type="bonus"}
Since backslash also has special meaning itself, if you want a backslash in your string, you need to use another escape character, like so: `g <- "here is a backslash: \\"`

To see a list of special characters, try typing `?Quotes` into the R console
```

Here is an important string to know about:

```{r}
h <- ""              # This string is empty!
```

`h` is a character string with no characters, called an _empty string_.

You can perform math on numeric data, so what can you do with strings?
The answer is, quite alot, using some functions that R provides.
Here are some of them:

```{r}
nchar(g)   # This prints out the number of characters in a string
```

```{r}
substr(g, 6, 10)   # This extracts just part of a string, using the start and stop positions you provide
```

```{r}
strsplit(g, " ")   # This splits the string up using a specified "delimiter" string, a single space in this case. 
```
```{block, type="bonus"}
When you split a string, this produces a _list_ containing a _vector_ of character strings. This is an example of how data can be organized in a structured way. 
We'll talk more about so called _data structures_ in the next section.
```

```{r}
paste("hello", "world")   # This combines multiple strings together into one string!
```

```{block, type="reflect"}
Remember that you can learn more about a function using `?`. Type `?paste` into R and read the documentation carefully. Can you determine what the "sep" argument does? What do you think would happen if we ran the code `print("hello", "world", sep="-")`?
```


There are other ways of manipulating strings, but we'll return to this later.

### Logical

Numeric objects can be any number, character objects can be any string of characters, but logical objects can only be two different values: True or False
Logical data types are also known as ["boolean" data types](https://en.wikipedia.org/wiki/Boolean_data_type).
Here we define some Logical objects:
```{r}
a <- TRUE
b <- FALSE
c <- T
d <- F
```
```{r}
print(a)
```
```{r}
print(b)
```
```{r}
print(c)
```
```{r}
print(d)
```

So you can see that we can define a logical object using the full name or just the first letter. 
Here's how to get the "opposite" of a logical object
```{r}
!a
```

Logical data are the simplest type, but there are actually some clever things you can do with them.
You can test whether simple mathematical expressions are true or false. 
```{r}
# create x and y
x <- 3
y <- 4
# check: is x less than y? (should give TRUE)
x < y
```
The third command is a way to check if the value of `x` is less than the value of `y`.
The result of this comparison is a logical, in this case, `TRUE`.
Here are other ways of making comparisons:
```{r}
x <= y  # check if x is less or equal to y
```

```{r}
x == y  # check if x is equal to y (note how you need two equals signs)
```

```{r}
x >= y  # check if x is greater or equal to y 
```

```{r}
x >= y  # check if x is greater than y 
```
Comparisons can be made using strings as well:

```{r}
x <- "Hello"
y <- "hello"
x == y
```
```{block, type="caution"}
Remember that R is case sensitive, and two strings must be _exactly_ the same to be considered equal.
```

Of course any object (like `x`) will be equal to itself:
```{r}
x == x
```


Surprisingly, logicals can be treated as numerics, where `TRUE` is treated as `1` and `FALSE` is treated as `0`.
Here are some examples:

```{r}
TRUE + TRUE  # TRUE is treated as 1
```

```{r}
FALSE * 7  # FALSE is treated as 0
```

```{r}
(2 < 3) + (1 == 2)  # What's going on here? 
```
The last example deserves some thought. Start with each expression in parentheses, and decide whether it will evaluate to true or false.
Then remember how logicals are treated as numbers, and determine what happens when you add them together.

```{block2, type="bonus"}
Numeric, integer, character, and logical data types are probably the most important data types to know in R, but there are others that were not covered here.
These include:

- complex
- factor
- raw

At least one of these (factor) will be covered later, but you can find more information about the other types [here](https://swcarpentry.github.io/r-novice-inflammation/13-supp-data-structures/)

```

```{block2, type="progress"}
In the R console, type the following R commands and observe the result

`x <- "5"`

`y <- 5`

`z <- (x == y)`

1. What data type is x?  (check with R using the `class` function)
1. What data type is y?
1. What data type is z?
1. What is the value of z, and why does this make sense?

```

Now that we've discussed different types of data, we'll now see how they can be structured together in meaningful ways. 

## Data Structures

```{block, type="reflection"}
Imagine a grocery list, shopping list, or to-do list. That list consists of a set of items in a specified order, and the list also has a length. Why do you think it's useful to organize these items into a list, rather than in some other fashion? Can you think of why it might be useful to store data in a list?
```

Often, you will need to work with many data of the same type, for example:
- A sequence of measurements through time
- A grid of values
- A set of phone numbers

In these circumstances, it would make sense to organize the data into a data structure. 
R provides multiple data structures, each of which are appropriate in various situations

### Vectors

A vector is just an ordered set of elements (in other words, _data_), all of which have the same data type.
Vectors can be created for the logical, numeric (double or integer), or character data types.
Here's an example of a vector:

```{r}
x <- c(1, 2, 3)  # this is a vector of numeric types
print(x)
```

Note that to create a vector, we use the `c` function, where c stands for _combine_.
This makes sense, because we are combining three numeric objects into a numeric vector.
We may determine the length of any atomic vector like so:

```{r}
length(x)
```
The `class` function will tell us what type of data is stored in a vector (which makes sense, because all elements of the vector have the same data type).
```{r}
class(x)
```
Here's how to create logical or numeric vectors:
```{r}
y <- c(TRUE, TRUE, FALSE, TRUE)
z <- c("to", "be", "or", "not", "to", "be") 
```
```{r}
class(y)
```
```{r}
length(y)
```
```{r}
class(z)
```
```{r}
length(z)
```
```{block2, type="reflect"}
The above statement states that all elements of a vector must have the same data type, so what do you think will happen if you try to create a vector using elements from different data types?
Here are some possibilities, can you think of another one?

- R will produce an error
- R will combine the elements somehow, but the result won't be a vector
- Something else?

Whatever happens, humans were behind the decision of how R should behave in this situation.
If you were in charge of making this decision, what would make the most sense?

```
```{block, type="progress"}
Let's try to create a vector of mixed type and see what happens.
Run the following commands in R and think about the output:

`m <- c(TRUE, "Hello", 5)`

`class(m)`

`print(m)`

What changes did R make when creating the vector?
```
What's happening in the above code is an example of _type conversion_, which we will talk more about later.
For now, remember that every element in an R vector is the same type.

You can create _empty_ vectors as placeholders, by indicating the data type and how many elements there are:

```{r}
empty <- numeric(10)   # this creates a numeric vector of length 10
```

```{block, type="reflect"}
This is the first instance of us using a name which is longer than a single character! This new vector is called _empty_.
```

Let's print the contents of the vector:

```{r}
print(empty)
```
Even though we didn't tell R what data to put in the vector, it put a `0` in each element.
This is the _default_ value for a new vector.

Here's how you can create new vectors of other types:

```{r}
empty_int <- integer(45)   # create integer vector with 45 elements
empty_cha <- character(2)  # create character vector with 2 elements
empty_log <- logical(1000)    # create logical vector with 1000 elements!!
```

```{block, type="progress"}
We saw that the default value for a numeric vector is 0. Use the code above to create empty integer, character, and logical vectors, then print them out to see what default values R has given to each element. Do these make sense?
```

What happens if we create a vector of length 1?
It turns out this is the same as just creating a single instance of that data type.
Observe how the following are the same.

```{r}
a <- numeric(1)  # create vector of length 1 (default value is 0, right?)
b <- 0           # create single numeric with value 0
a == b           # compare a and b to see if they are the same.
```
```{block, type="bonus"}
It turns out, you _can_ create a vector of length 0, which contains 0 elements. This may sound odd, but can happen sometimes!
However, you _cannot_ create a vector of negative length (e.g. `logical(-1)` won't work), or a fractional length (e.g. `character(12.7)` won't work).
```

#### Accessing and Changing Elements

After you've created a vector, how do you put your data in them?
Here's how you can change the value of a specific element:

```{r}
a <- c(1, 2, 3)  # create numeric vector of length 3
a[2] <- 4        # change the value of the second element of a to 4
a                # print the result
```

See how the second element of `a` has changed?
So you can access a specific element using square brackets: `[` and `]`.
In fact, if you want to know the value of the third element (without changing anything), just use:

```{r}
a[3]    # access the third element
```

```{block, type="progress"}
What do you think will be the result of the following code (hint: the result will either be `TRUE` or `FALSE`)?

`vec <- c(4, 5, 6)  # create a vector`

`vec[3] == 6   # Remember what == does?`

Once you make a guess, try it in R and see if you were correct.
```

#### Working with vectors
TODO: add sort/order?

You can do many things with vectors that you can with single instances of each data type. 
Recall, you can add a number to a numeric object:

```{r}
a <- 3   # create a numeric object
a + 4    # add a number to the object.
```

The same thing is possible with numeric vectors:

```{r}
a <- c(1, 2, 3)   # create a numeric vector
a + 4             # add a number to EACH ELEMENT of the vector!
```

This type of behavior is called _elementwise_ behavior. That is, the operation is performed on each element separately.
Here are some other elementwise operations:

```{r}
a - 3
```
```{r}
a * 1.5
```
```{r}
a ^ 2
```
```{r}
a == 2
```

R has some functions which _summarize_ the values in a vector.
One such function is the `sum` function, which adds the values of each element in the vector:
```{r}
print(a)  # print the elements of a as a reminder
sum(a)    # add all the elements of a together.
```
```{block, type="bonus"}
Other examples of summary functions include `max`, `min`, `mean`, and `sd`. We'll talk about these and other summary functions later.
```

Some operations work on _two vectors_, as long as they are the same length:

```{r}
b <- c(1, 0, 1)
a + b
```

```{r}
b * a
```

```{r}
a ^ b
```
You can even compare two vectors, and the result will be a logical vector:

```{r}
z <- a > b   # compare a and b, element by element, assign the result to z
z            # print the value of z
```
The first logical value is the result of `a[1] < b[1]`, the second logical value is the result of `a[2] < b[2]`, etc. 
what operations can we perform on character vectors?
Here are some examples:
```{r}
z == TRUE   # which elements are TRUE?
```
This just produces `z` again (Do you see why?).
Here's how to get the logical "opposite" of `z`:

```{r}
z == FALSE
```
Or, as we saw before, we can use `!`, which operates on each element of `z`:
```{r}
!z
```

Remember how logical objects can be treated as numeric objects (either a 0 or 1)?
If we use this with the `sum` function to determine how many elements are `TRUE`:

```{r}
sum(z)
```
Here's another example of using the sum function on a logical vector:
```{r}
sum(a == b)  # how many elements do a and b have in common?
```
So there are no elements where `a` and `b` are the same.

```{block, type="bonus"}
Logical vectors can also be used to access all elements of a vector for which a certain condition is true.
We'll see how to do this later on.
```

Let's create some character vectors and explore a few things we can do with them:

```{r}
a <- c("I", "have", "to", "have", "a", "donkey")
b <- c("You", "want", "to", "sell", "a", "donkey")
```

First, we can do elementwise comparison (assuming equal length), just as we did for numeric vectors:

```{r}
a == b
```

To search for specific character strings in a character vector, you can use the `grep` function:

```{r}
grep("have", a)   # search the vector a for the phrase "have"
```
This result shows that the phrase "have" occurs in elements 2 and 4 of `a`!
What if we search for a phrase that doesn't occur?

```{r}
grep("raddish", a)
```
The result is an integer vector of length 0, meaning there are no elements that match the phrase!

#### Vectors of different types

What if we try to perform operations between vectors of different types?
This will work in some cases, but not others. Here are a few examples:
```{r}
a <- c(1, 2, 3)
b <- c("I", "am", "sam")
c <- c(TRUE, TRUE, FALSE)
```

```{r, error=TRUE}
a + b   # Can you add a numeric vector to a character vector? 
```

```{r, error=TRUE}
a + c  # can you add a numeric vector to a logical vector?
```
```{block, type="reflect"}
We see that you can't add a numeric vector to a character vector, but you _can_ add a numeric vector to a logical vector. 
Why is this?
```
```{block2, type="progress"}
Predict whether the following are possible:

- Can you can multiply a character vector with a numeric vector?
- Can you can multiply a logical vector with a numeric vector?
  
Check whether you are correct by creating some vectors in R and attempting to multiply them together. Can you make sense of the answer?
  
```

#### Special Numeric Vectors

There are a few special ways of creating a numeric vector which can be very useful, so we'll mention them here.
The first way creates a sequence of all integers between a starting and ending point:
```{r}
d <- 1:5  # create sequence starting at 1 and ending at 5
d
```

Here's a longer example:

```{r}
d <- 1:100  # create sequence starting at 1 and ending at 5
d
```
```{block, type="caution"}
In this example, the R output can't be shown on a single line, so it must be placed on multiple lines. 
Notice that each line has a different number in brackets: `[1]`, `[19]`, `[37]` etc.
This number indicates which element of the vector is the start of that line.
So we finally have an explanation for the `[1]` which is displayed with all R output.
It's simply indicating that this is the _first element_ of the output.
This also reflects the fact stated earlier that any R object can be considered a vector of length 1!
```

Another way to create a numeric vector is using the `seq` function, which allows you to specify the _interval_ between each vector element. 
For example:

```{r}
e <- seq(2, 100, 2)
e
```

Or you can also specify how long you want the vector to be, and `seq` will determine the appropriate interval to make the elements evenly spaced.

```{r}
seq(1, 10, length.out=3)
```
```{r}
seq(1, 10, length.out=5)
```


#### Another Data Type: Factor

In the previous section, we avoided talking about the _factor_ data type, because we need the concept of vectors to appreciate their purpose, but now we are equipped to talk about them.
Consider the following example of a _character vector_:
```{r}
cha_vec <- c("cheese", "crackers", "cheese", "crackers", "cheese", "crackers", "cheese")
```

There are seven elements in this vector (`length(cha_vec)` is `7`), but there are only _two unique_ elements, "cheese" and "crackers".
Imagine having two write down this vector on a piece of paper, and the space it would take.
Now imagine writing down instead: 

1, 2, 1, 2, 1, 2, 1

1 = "cheese"

2 = "crackers"

This second method writes down numbers instead of character strings, but also keeps a record of which numbers correspond to which character strings.
The total amount of space taken up on the piece of paper is smaller for the second method, and the amount of space saved would be even larger if the character vector were longer and had more repeated elements.

This is the essence of what a _factor_ data type is: A character vector stored more efficiently on the computer.
For a factor vector, R stores an integer vector (which often takes less space than a character vector), and also maintains a "lookup table" which keeps track of which integers correspond with which character strings.

To illustrate, let's create a factor variable:
```{r}
# create a new factor variable from our existing character vector:
fac_vec <- factor(cha_vec)   
```

Notice how we started with a character vector and used the `factor` function to create a factor from it.
If we print the new vector,
```{r}
fac_vec
```
it displays the elements as we would expect, but also includes another line of output giving `Levels`.
This shows that there are only two unique character strings, which are called _factor levels_.
Since R is using integers "behind the scenes" to store the vector, we can see those integers by using the `as.integer` function:
```{r}
as.integer(fac_vec)
```
This is another example of _type conversion_, which we will discuss soon.

```{block, type="caution"}
In some situations, numbers may get treated as characters, like so:

`x <- c("4", "5", "6")`

This may pose an issue if this character vector gets converted to a factor, because the "behind the scenes" integers may not agree with the `Levels`, which represent the original data.
This can easily happen when reading in data from a file on your computer, if you're not careful.
We'll talk more about this later.
```

There are a few neat things you can do with factor vectors.
By changing the levels, you can quickly change all occurrences of a string at once.
For example:
```{r}
print(fac_vec)
levels(fac_vec) <- c("peas", "carrots")   # change the levels of fac_vec
fac_vec
```
There is more to be said about factors, but this is all we will explore at this point.

```{block, type="bonus"}
In newer versions of R, all strings are _treated like factors_ behind the scenes, meaning there's really no difference between factor and character types in terms of how much space they take up in the computer's memory.
However, R still treats the two types differently, so it's important to remember that they are different!
```

#### Combining Vectors

Given two vectors, it's easy to combine them into one vector:
```{r}
a <- c(1, 2, 3)
b <- c(4, 5, 6, 7)
c(a, b)   # combine vectors a and b
```
The combine function (`c`) is smart enough to recognize that `a` and `b` are vectors, and performs _concatenation_ to create the resultant longer vector.
You can also use the combine function to add a single element to the end of a vector:
```{r}
a <- c("CEO", "CFO")   # initialize 
a <- c(a, "CTO")       # redefine a by combining a with a new element
a
```

```{block, type="caution"}
In R, there may sometimes be more than one way to do the same thing, and one of the ways might be much faster or take much less computer memory to do.
In other words, two sets of R commands be _correct_, but one may _perform better_ than the other.
Writing "performant" (high performance) code is an advanced topic that we will not discuss much in this introductory course.
You've just seen one way to add an element to the end of a vector, but if you do this _a lot_ (perhaps in a for loop, which we'll talk about later), it can be _very slow_.
In this situation you're better off creating the whole vector at once and updating each element as needed.
```

What if you try to combine vectors of different types?
```{r}
a <- c(1, 2, 3)
b <- c("four", "five")
c(a, b)
```
Again, we see that the `c` function has converted all elements to be character strings, and the resultant vector is a character vector.
Since we've seen type conversion arise a few times now, it's appropriate to talk more explicitly about how it works.
We'll do that in the next section.

#### Type conversion

There may be times when you'd like to convert from one type of data into another.
An example would be the character string `"1"`, which R _does not_ view as a number.
Therefore, the following does not work:
```{r, error=TRUE}
"1" + "2"   # R can't add two character string
```
To remedy issues like this, R provides functions in order to convert from one data type into another:
- as.character: converts to character
- as.numeric: converts to numeric
- as.logical: converts to logical
- as.factor: converts to factor

Using these functions, R will "do its best" to convert whatever you start with into the desired data type, but it's not always possible to make the conversion.
Below are a few examples which do and don't work well.

Converting from a numeric to a character vector is always possible:
```{r}
x <- c(3, 2, 1)
```
```{r}
y <- as.character(x)   # Here's how to convert to a character vector
print(x)
print(y)
```

However, converting from a character vector to a numeric only works if the characters represent numbers.
Any element that won't convert will be given 

```{r}
w <- c("1", "12.3", "-5", "22")   # this character vector can be converted to numeric
as.numeric(w)
```
```{r}
v <- c("frank", "went", "to", "mars")   # this character vector can't be converted to numeric
as.numeric(v)
```
None of the elements can be converted into a number, so R prints a warning message, and the result is an `NA` in each element, which stands for "not available".
`NA` indicates that a value is missing, and can arise in many different ways, which we will not explain here.

```{block, type="bonus"}
`NA` values have interesting behavior in R.
Generally, anything that "touches" an `NA` becomes an `NA`.
You can try out these commands for yourself to see what happens:

`NA * 0`

`NA - NA`

`c(NA, 1, 2)`

```

If only part of a vector can be converted, then the result will contain some converted values and some `NA`'s:
```{r}
u <- c("1.2", "chicken", "33")
as.numeric(u)
```
What other conversions are possible?
Character vectors can also be converted into logical:
```{r}
s <- c("TRUE", "FALSE", "T", "F", "cat")   # all but the last element can be converted to logical
as.logical(s)
```
Based on the examples we've seen before, it should make sense that numeric vectors containing 0 or 1 can also be converted into a logical vector:
```{r}
as.logical(c(1, 0, 1, 0))  # here we create the vector and convert it in the same line
```
```{block, type="progress"}
Logical vectors can also be converted into character or numeric vectors. 
Based on what you know, make a prediction about what the following commands will produce:

`as.numeric(c(T, F, F, T))`
`as.character(c(T, F, F, T))`

Check your predictions by typing running the commands in R.
```

Remember that "solo" objects are just vectors of length 1, so any of these type conversions should work on a single object as well, like so:
```{r}
as.numeric("99")
```

Along with the conversion functions `as....`, there are companion functions which simply check whether a vector is of a certain type:

- is.character: checks if character
- is.numeric: checks if numeric
- is.logical: checks if logical
- is.factor: checks if factor

Here are some examples:
```{r}
a <- c("1", "2", "3")
is.character(a)
```
```{r}
is.numeric(a)
```
```{r}
a <- as.numeric(a)
is.character(a)
```
```{r}
is.numeric(a)
```

```{block, type="bonus"}
As we've seen, type conversion is sometimes performed automatically, specifically when using the combine function (`c`).

To understand more about this, try typing `?c` to bring up the documentation, and have a look at the "Details" section.
```

TODO: include conversion b/t character vec and factor vec.

### Lists

### Matrices

### Arrays


## Practice

```{block, type="progress"}
asdf
```


## R Objects

### _Everything_ is an object in R

### Assigning Objects


```{block, type="bonus"}
asdf
```


### Inspecting objects

str, names, dim


### Null Objects



## Quiz
```{block, type="assessment"}
asdf
```


## Loading / Saving Data

### "Taster"(?) list of file forms and sources

### reading/writing csv

### Best practices

principles of Tidy Data (wickham 2014)

raw data as read only

## Downloading and Saving

```{block, type="video"}
downloading and saving example csv from canvas or website
```

## Working With Data

### Summarizing vectors

Mean, std, etc.

### Summarizing matrices

### Summarizing vectors

### Basic Plotting

```{block, type="bonus"}
ggplot example
```

### Basic indexing

### Advanced indexing

```{block, type="bonus"}
dplyr example
```

## Practice

```{block, type="progress"}
asdf
```

## Basic Control Flow

If/else

loops (for, while)

switch

## Advanced Control Flow

*apply family

## Writing FUnctions

Function scope

```{block, type="bonus"}
- Pass by value, contrast with other languages
```

## Working With Popular Packages



## Assignment

```{block, type="assessment"}
Make R Markdown PDF that covers most/all of CH4: read in data, do basic things with it.
```
