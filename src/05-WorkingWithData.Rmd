# Working with Data


```{block, type="caution"}
Portions of this chapter are still under construction. Sections in progress will start with a caution block like this one.
```

> The goal is to turn data into information, and information into insight.” – Carly Fiorina, former CEO of Hewlett-Packard

In the previous chapter, we've talked about the different types of data that R stores and the different structures that R stores data _in_.
We've mostly just made up numbers, character strings, and logical values for illustration.
In this chapter, we'll use R to do interesting things with _real data_.
This is by far the most popular use of the R programming language, and arguably the most fun!
You'll learn how to read data sets into R, do interesting things with them, and save your results.

## Quick Example

Before diving into detail, let's do a quick example so you can begin to see what is possible with data in R.
As we mentioned in the last chapter, R includes some pre-packaged data sets, which you can access with the `data()` command.
One of the data sets is `Seatbelts`, which documents road casualties in Great Britain between 1969 and 1984.
Firstly, we need to convert `Seatbelts` to a dataframe, because it starts out as a "Time-Series", which we haven't discussed.
```{r}
Seatbelts <- data.frame(as.matrix(Seatbelts), date=time(Seatbelts))   # convert Time Series to data frame
```
We've also added a month and year column 

look at the dimensions of the data set with the `dim` command:
```{r}
dim(Seatbelts)   # get the number of dimensions in the Seatbelts dataframe
```
This shows that there are 192 rows (months), and 9 columns (variables measured each month).
We could also determine the number of rows and columns separately using the `nrow` and `ncol` functions.
To view the first few rows of the Seatbelts dataframe, use the `head` command:

```{r}
head(Seatbelts)  # view first few rows of the Seatbelts dataset
```

This is a good way to learn which variables are being measured (columns) and see some example observations (rows) for each variable.
Because these data are included with R, more information about each variable can be found with:

```{r, eval=F}
?Seatbelts
```

Next, let's view a summary of each column with the summary function:

```{r}
summary(Seatbelts)
```

Since each column is numeric, R shows a five number summary (minimum, first quartile, median, third quartile, maximum) and mean for each column. 
We learn, for example, that the average number of drivers killed per month is 1670, and that the greatest price of petrol was £0.13 per litre!
Let's view a histogram of `DriversKilled`:

```{r, fig.cap="Histogram of Drivers Killed in Seatbelt data"}
hist(Seatbelts$DriversKilled, breaks=20)
```
We see that in some months, more than 150 drivers were killed!
We can calculate how many exactly like so:

```{r}
sum(Seatbelts$DriversKilled > 150)
```
To investigate the effect of the seat belt law, let's create a scatter plot Drivers killed against time:
```{r, fig.keep='all', fig.cap="UK Seatbelt deaths vs time"}
plot(Seatbelts$date, Seatbelts$DriversKilled)
```
By adding a `col` argument to the `plot` function, we can color the points based on whether the law was in effect:

```{r, fig.keep='all', fig.cap="UK Seatbelt deaths vs time, red = no seatbelt law, green = seatbelt law"}
plot(Seatbelts$date, Seatbelts$DriversKilled, col=(Seatbelts$law+2))
```

There do appear to be fewer deaths, but there is so much fluctuation in deaths each year that it's difficult to tell.

Let's change the x-axis to reflect month of the year instead of date:

```{r, fig.cap="UK Driver Deaths vs. Month"}
plot((Seatbelts$date %% 1) * 12 + 1, Seatbelts$DriversKilled, 
     xlab = "Month", col=Seatbelts$law + 2)
```
This plot shows that there is a clear seasonal effect in the number of deaths with higher deaths occurring in the Fall/Winter compared to Spring/Summer.
We can also see that within each month, the traffic deaths after enacting the Seatbelt law are among the lowest.

```{block, type="progress"}
Another data set included in R is `mtcars`. Following the example above, find the dimension of `mtcars` and have R print out a summary of each column, then create a scatter plot of fuel economy (`mpg`) to engine displacement.
What do you observe about the relationship between these two variables?
```

This concludes the quick example.
In the rest of this chapter, we'll talk in more detail about the different steps of working with data, and how to complete them using R!

```{block, type="reflect"}
People often use data in order to answer questions, but often times, learning about data can generate even _more_ questions than it answers.
Take a moment to think of a question that you have about the `Seatbelts` dataset. 
Do you think the question can be answered using the data alone?
If not, what other sources of data might be available which can help answer the question?
```

```{block, type='feedback'}
Any feedback for this section? Click [here](https://docs.google.com/forms/d/e/1FAIpQLSePQZ3lIaCIPo9J2owXImHZ_9wBEgTo21A0s-A1ty28u4yfvw/viewform?entry.1684471501=Quick%20Example)
``` 

## Reading / Writing Data

Of course, if we want work on data which is NOT included in R, then we have to _read_ that data into R in order to work with it.
That is, the data are normally somewhere on your computer's hard drive (or SSD), and you must run a command in R which _reads_ that data into your R environment. 


### Olympic Athletes Example

Let's look another example, this time with a data set of Olympic athletes.
Here's how we'll _read_ them into R:

```{r}
# Read the csv file into a data frame called athletes
athletes <- read.csv("data_raw/olympic_athletes.csv")

# print a summary of the data frame
summary(athletes)
```

```{block2, type="caution"}
The above command only works because the data set is in a particular location (the data folder), and is in a particular format (csv). 
In the sections that follow, we'll discuss how to address both of these issues.
```

### Locating your data set

R is capable of reading data from your computer, no matter where it is, as long as you "point" R to the correct location.
The location is usually specified with a _file path_, which is a character string that specifies the folder structure that holds your file.
By default, R starts "looking" from the current working directory, and the file path used was `data_raw/olympic_athletes.csv`.
This means that R will look inside the current working directory for a folder called `data_raw`, and if it exists, R will look inside `data_raw` for a file called `olympic_athletes.csv`.
In this class, you should be working within an rstudio project, which automatically sets the working directory.
If you created the folders as instructed earlier, then you should already have a `data_raw` folder in your project directory.

```{block2, type="progress"}
Download the olympic athletes data set from [this link](data_raw/olympic_athletes.csv) and save it in your data_raw folder.
In your progress check document, simply write: "Olympic Data Downloaded"
```

### Reading CSV files

A common way of storing data in a computer file is called CSV, which stands for _comma-separated values_.
These files are _plain text_, so you can open them in any text editor like Word, Notepad, or even Google Docs.
Just like a data frame, these files contain data in rows and columns, where on each line, the columns are _separated_ from each other with a comma (`,`), which is technically called a _delimiter_.
Programs like Excel, Google Sheets, and R can read these files and understand their row-column structure.
In R, the function to read CSV files (as you saw above) is `read.csv`.
In addition, if you call up the help file for read.csv using `?`, you'll see that there are other similar functions as well, including `read.table`, and `read.delim`.

```{block, type="bonus"}
In many object oriented languages, the "dot" (`.`) is a special symbol used to access an attribute or method of an object.
In R, however,  variable names and function names can contain a dot, and the dot has no special purpose. 
There are some exceptions, however, that relate to function overloading, and R formulas, but these are advanced topics that will not be discussed here.
```

These functions are actually all different variations of the same, generic, function called `read.table`.
The difference is that `read.csv`, `read.delim`, and the others make different assumptions about what delimiters are being used, and how decimal numbers are displayed (e.g. one-and-a-half may be written as `1.5`, or `1,5` depending on where you live).
We will discuss functions and arguments more in the next chapter, but for now, see the following table for when to use each function:

```{r}
df <- data.frame(Function=c("read.table", "read.csv", "read.csv2", "read.delim", "read.delim2"), Delimiter=c("Must specify with sep=...", ",", ";", "\\t (tab)", "\\t (tab)"), Decimals=c(".", ".", ",", ".", ","))
knitr::kable(df) %>% kable_styling()
```

Any of these functions accepts the argument `header=FALSE`, which indicates that the first row of the file _does not_ contain column names.
Without this argument, R will assume the first row _does_ contain column names.
If our Olympic athletes data did not contain headers in the first row, we would use this:

```{r, eval=F}
athletes <- read.csv("data_raw/olympic_athletes.csv", header=FALSE)
```

###  Writing CSV files

R also has the capability to _write_ a dataframe to a CSV file on your computer, that could then be read by Excel, Sheets, etc.
Let's suppose we wanted to save a version of the athletes data with only the `Sex` and `Age` columns.
We could use the `write.csv` function:

```{r}
# make a new dataframe with only the Sex and Age columns
athletes2 <- athletes[,c("Sex", "Age")]

# save the new data frame as a CSV in the clean data folder
write.csv(athletes2, "data_clean/olympic_athletes_age_sex.csv")
```

Notice we created a new dataframe by selecting only the desired columns.
We will talk more about different ways to select data when we discuss _indexing_.
Notice also that the write.csv function requires that we give it the name of the dataframe being saved (`athletes2`), then the file path for the csv file that the data will be written to (`"data_clean/olympic_athletes_age_sex.csv"`).

```{block, type="caution"}
`write.csv` is an example of a function which takes _multiple arguments_, separating them with a comma (`,`). Usually, these arguments must be specified in order, but more will be said about this later.
```

```{block, type="progress"}
Create a version of the athletes dataframe which contains the athletes' names and their sports.
Save the new dataframe as a csv file in your data_clean folder with the file name "olympic_athletes_name_sport.csv".
Include the code in your progress check assignment.
```

```{block, type="caution"}
The `read` and `write` terminology may seem odd if you have not heard those terms before.
Your computer's hard drive (or SSD) will store data which will be remembered even after you turn off your computer.
The process of getting data from, and putting data on your hard drive (or SSD) is called _reading_ and _writing_.
```

```{block, type='feedback'}
Any feedback for this section? Click [here](https://docs.google.com/forms/d/e/1FAIpQLSePQZ3lIaCIPo9J2owXImHZ_9wBEgTo21A0s-A1ty28u4yfvw/viewform?entry.1684471501=Reading%20Writing%20Data)
```

## Summary Statistics

Reading and writing data is useful, but the power of R is _doing interesting things_ with the data!
Let's perform a few operations with the Olympic athletes data to demonstrate some important functions for data analysis. 
As we've seen, the `summary` function automatically performs some summary statistics on each column of a dataframe.
Let's see how to produce these and other results manually.

### Quantitative Variables

To showcase the functions R provides to summarize quantitative variables, we'll look at the `Age` column of our dataframe, which is stored as an integer vector in R.

```{block, type="reflect"}
What other R data types might be used to store quantitative data?
```

However, `Age` contains `NA` values, as we know from running the following function:

```{r}
sum(is.na(athletes$Age))   # count how many NA's are in the Age column
```

```{block2, type="reflect"}
Pause and think through what's happening in the above code. The `is.na` function returns a logical array which is true whenever the `Age` column is `NA`. So why does the `sum` function produce the number of `NA`'s?
```

As a cleaning step, we must first remove the `NA` values:
```{r}
age <- athletes$Age         # assign the Ages column to a variable
age <- age[!is.na(age)]   # extract only the elements which are not NA (more on this when we discuss advanced indexing)
```

```{block, type="bonus"}
This type of "data cleaning" is a very common first step when performing data analysis. You will get more opportunities to clean data later in the course.
```

Here are some functions R provides to summarize quantitative variables.
```{r}
age_min <- min(age)     # find the minimum age
age_med <- median(age)  # find the median age
age_max <- max(age)     # find the maximum age
age_mean <- mean(age)   # find the average age
age_sd <- sd(age)       # find the standard deviation of age
age_var <- var(age)     # find the variance of age
```

Let's put all these results in a named list.
In the following code, read the comments carefully to understand how the code is being organized onto multiple lines.

```{r}
# Create a list containing all the stats
age_stats <- list(  # R knows that this command continues until a closed parenthesis
  min = age_min,   
  median = age_med, 
  max = age_max,    
  mean = age_mean,  
  sd = age_sd,      
  var = age_var
)  # this could all go on one line, but it looks more organized this way.
age_stats
```

```{block2, type="progress"}
Create a list called `weight_stats` with the mean, median, and standard deviation of the `Weight` column.
```

Visualization will be discussed more later, but we'll show one plot now, to show how multiple summary statistics can be shown at the same time.

```{r, eval=F}
hist(age, breaks=50)
abline(v=age_mean, col="blue", lty=2, lwd=3)
abline(v=age_med, col="red", lty=2, lwd=3)
```
```{r, echo=F}
# not shown but knitted
{
hist(age, breaks=50)
abline(v=age_mean, col="blue", lty=2, lwd=3)
abline(v=age_med, col="red", lty=2, lwd=3)
}
```
It looks like the distribution of `Age` is _right skewed_, consistent with the fact that the mean is greater than the median.

### Categorical Variables

To showcase the functions R provides for categorical variables, we'll look, at the `Sport` column, which is stored as a character vector in R.

```{block, type="reflect"}
What other R data types might be used to store categorical data?
```

Are there any `NA` values in this column?

```{r}
sport <- athletes$Sport
sum(is.na(sport))
```

It turns out the answer is no, so there's no need to remove anything.
In a character vector like this, we expect there to be many duplicated values.
We can see a list of all the unique values with the following:

```{r}
unique(sport)
```

Using the numbers in brackets to the left as our guide, we can see that there are 66 unique values, but this can also be determined by running:

```{r}
length(unique(sport))
```
It would be nice to see how many times each entry occurs in the data set.
This is what the `table` function does:

```{r}
table(sport)
```

Let's save this table to a list as before:
```{r}
# assign summary statistics to variables
sport_n_unique <- length(unique(sport))
sport_counts <- table(sport)

# combine them into a list
sport_stats <- list(
  number_unique = sport_n_unique,
  counts = sport_counts
)
```

Again, a visualization may be useful here:

```{r, eval=F}
par(mar=c(5,15,4,2) + 0.1)  # command to make the labels fit
barplot(table(sport), horiz=T, las=2)   # bar plot
```
```{r, fig.height=20, echo=F, fig.asp=2}
# evaluated, but not shown (because RMarkdown needs brackets)
{
par(mar=c(5,15,4,2) + 0.1)  # command to make the labels fit
barplot(table(sport), horiz=T, las=2)   # bar plot
}
```

So we see that in our data set, athletics, swimming, and gymnastics have the most athletes (remember, each row is an athlete).

```{block2, type="progress"}
Create a list called `season_stats` with the a table of counts for the `Season` variable.
```

```{block2, type="caution"}
It's always important to remember what the rows of your data set represent.
In the Olympic athletes example, one athlete may occupy multiple rows, if they competed in multiple olympic games.
This impacts how you should interpret the summary statistics computed above (mean, median, counts, etc.).
```
```{block2, type="reflect"}
Since an athlete may show up for multiple olympic games, what impact could this have on summary statistics for the `Height`, `Weight`, and `Sex` variables? Can you give an example of what might happen? What other variables may be impacted? What R code would you write to determine if an athlete occurred multiple times in the dataframe?
```

### Saving an RData file

Finally, we may want to save these results for use _in R_ later.
First, we'll create a new list to put our two stats list _in_ (remember, we can have lists inside of other lists!).
```{r}
# Create list
athlete_stats <- list(
  age = age_stats,
  sport = sport_stats
)
```

```{block2, type="bonus"}
Remember that the `names` function retrieves the column names for a dataframe? It also retrieves the names of a list (after all, a data frame is just a fancy list, right?)!
The following commands may be useful for remembering what the contents of our stats list:
  
  - `names(athlete_stats)`
  - `names(athlete_stats$age)`
  - `names(athlete_stats$sport)`

```

To save these results, we can use the `saveRDS` function:
```{r}
saveRDS(athlete_stats, "data_clean/athlete_stats.rds")
```

Later, we can use the following command to load the RDS file back into R:
```{r}
rm(athlete_stats)  # remove athlete stats to prove we are loading it from the hard drive

athlete_stats <- readRDS("data_clean/athlete_stats.rds")  # load the RDS file and name it athlete_stats

athlete_stats$age   # show that we have loaded the data by printing the age stats
```
```{block2, type="caution"}
Notice the file ends with _.rds_, indicating that this is a special RDS type which can only be read by R.
This is different from other data formats like CSV, which are plain text and can be read by other programs like Excel or Sheets.
RDS should only be used when you want to save work that you want to resume in R later.
If at all possible, you should prefer using plain text formats rather than RDS.
```

```{block2, type="bonus"}
RDS stands for _R Data Serialization_. This is R's version of object serialization, just like the io.Serializable interface in Java or the pickle module in Python.
As with other languages, R's serialization can only be used in R.
```

The RDS format works for any R Object, not just lists, so it can be used for vectors, matrices, factors, and even functions.

```{block, type='feedback'}
Any feedback for this section? Click [here](https://docs.google.com/forms/d/e/1FAIpQLSePQZ3lIaCIPo9J2owXImHZ_9wBEgTo21A0s-A1ty28u4yfvw/viewform?entry.1684471501=Summary%20Statistics)
``` 

## Data Formatting

Before we continue working with data, here are a few comments about data formatting.
Many data sets can be thought of as one or more _observations_ of one or more _variables_.
R functions work best when the data are formatted into rows and columns, so that each row is an observation, and each column is a variable.
Unfortunately, sometimes data do not follow this convention, or worse, it may not be clear what the observations or variables are.
Working with data often involves answering multiple questions, and different questions may require thinking of observations and variables differently.
In R, there are ways of changing the structure of data to suit your particular needs, but these are intermediate topics which will not be discussed here.

```{block, type="bonus"}
One concept related to data organization is called "Tidy Data", which you can read more about [here](https://vita.had.co.nz/papers/tidy-data.pdf). This focus on tidyness has led to the development of a set of R packages collectively called the "tidyverse", which has become very popular for R analysis. The tidyverse will not be covered in this class, but a later module will provide extensive experience with it.
```

### "Raw" data vs. "Clean" data.

Why is there a "data_raw" folder and a "data_clean" folder, and not just a "data" folder?
The idea is that the data_raw folder contains all of the _original_ data sets that you start with, before any cleaning or summarization take place, and any cleaned, modified, or created data sets that result from your data analysis should be stored in the "data_clean" folder (or possibly even a "results" folder).
This distinction ensures that the original data sets are preserved in their unedited state, just in case you need to start over from the beginning to answer a different question, and in order for others to easily replicate your work.
This is why the data in the folder should be thought of as _read only_. 
Sometimes people even modify the permissions of the raw data files on their computer to prevent anyone from accidentally deleting or overwriting the raw data.
The "clean" moniker comes from the fact that often times data sets need some "cleaning" such as removing duplicates, `NA` values, discarding irrelevant data, etc.
There are many other ways of organizing data, but the principle here is to separate the original data sets from any intermediate data sets. 

```{block2, type="reflect"}
Perhaps you've never thought about how data should be structured.
Consider an experiment which measures the temperatures of five guinea pigs is measured for each of four different days.
Think about organizing each row to be a guinea pig and each column to be a day. 
Can you think of an R function to compute the average tempareature on day 1?
How about the average temperature for guinea pig 3?
How do your answers change if the data are arranged with days as the rows and guinea pigs as columns?
Can you think of another way to organize the data?
```


```{block, type='feedback'}
Any feedback for this section? Click [here](https://docs.google.com/forms/d/e/1FAIpQLSePQZ3lIaCIPo9J2owXImHZ_9wBEgTo21A0s-A1ty28u4yfvw/viewform?entry.1684471501=Data%20Formatting)
``` 

## Indexing 

```{block, type="caution"}
This section is still under construction
```

### Basic indexing

For different data types

matrices: can use single index


### Advanced indexing

logical based indexing

which function

nested indexing: [[1]][3]

```{block, type="bonus"}
dplyr example
```
```{block, type="feedback"}
Give me some [feedback](https://forms.gle/2Fw8y4aY51ijdmyE9) about the content in this section.
```

## Basic Plotting

```{block, type="caution"}
This section is still under construction
```

```{block, type="bonus"}
brief ggplot example
```

```{block, type="caution"}
Remember to pay close attention to the syntax when using ggplot. R won't work if parenthesis or quotes are not paired. If you're adding multiple layers, put each on a new line.

Adding structure to make your code more readable is like doing your future self a favor (and anyone reading your code).
```

## Vignettes

```{block, type="caution"}
This section is still under construction
```

In this section, you'll gain more experience working with data by following along with some more data analysis examples.
