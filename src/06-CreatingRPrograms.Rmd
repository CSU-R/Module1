# Performing Effective Data Analysis

```{block, type="caution"}
This chapter is still under construction, sections are marked if incomplete.
```

> "Learning to write programs stretches your mind, and helps you think better, creates a way of thinking about things that I think is helpful in all domains." â€”Bill Gates

```{block, type="reflection"}
In the previous chapter, you learned how to load a data set, compute summary statistics, and create visualizations.
Suppose instead of just one data set, you had to do analysis on 100 different data sets.
Will you have to write 100 times the amount of code?
Now suppose that instead of 100 data sets, you have one data set and 100 columns, and you would like to create a visualization of each column. 
As you've seen, different types of data merit different types of visualizations.
Will you have to manually examine each column and write the appropriate code to visualize that column?
Clearly these scenarios (and many others) would benefit from _smarter_ R programs.
```

In this Chapter you'll discover ways to make R do _more_ work and letting you do _less_.
This is where the true power of R as a programming language will be harnessed, and you will be able to write less code and perform more effective analysis.
You will also be able to reduce mistakes and increase consistency in analysis, as well as better communicate your work to others.
This chapter is where you will gain the skills to move you from being able to work with data to being able to perform effective data analysis. 
It will all start with basic logic, in the next section!


## Basic Control Flow

When you write R code, you are creating commands that R will execute one at a time _in order_, from top to bottom. 
This is the basic _flow_ of an R program, but R also provides ways that you can _control_ the flow, using basic logic.
In this section, we'll introduce a few ways of controlling the flow of an R program, but first, we need a data set to work with.

Our working example for this chapter will be the latest (as of this book's writing) provisional estimates of COVID-19 Deaths in the United States, available from the Centers for Disease Control at [this link](https://data.cdc.gov/NCHS/Provisional-COVID-19-Death-Counts-by-Sex-Age-and-S/9bhg-hcku/data).
We've downloaded the data and saved it in the `data_raw` folder, and you should do the same (the data are also available [here](data_raw/Provisional_COVID-19_Death_Counts_by_Sex__Age__and_State.csv))
First, let's load the data and do some minor cleaning:

```{r}
# Load the data.
# The "Footnote" column has hyphens, which only display correctly if we specify "UTF-8" encoding.
covid <- read.csv("data_raw/Provisional_COVID-19_Death_Counts_by_Sex__Age__and_State.csv", fileEncoding = "UTF-8")
# remove rows with state totals. This will mess up our summary statistics later
covid <- covid[!grepl("Total", covid$State),]
# remove all ages category
covid <- covid[covid$Age.group != "All ages",]
```

```{block, type="progress"}
Download the covid data into your data_raw folder, and load/clean it using the code above.
```

### Loops 


One of the first things we might like to do with our data set is create visualizations. 
This data contains deaths data for different states, age groups, and sexes, let's pick a state and sex, create a bar chart for deaths in different age groups, and save the image to the `output` directory:

```{r, eval=F}
# Select only Females from Colorado
covid_co_f <- covid[(covid$State == "Colorado") & (covid$Sex == "Female"),]

# save a barplot of the deaths by age group
png("output/covid_deaths_by_agegroup_colorado_female.png")
par(mar = c(9, 4, 2, 2))
# The COVID.19.Deaths vector doesn't have row names, so we specify the bar labels with names.arg 
barplot(covid_co_f$COVID.19.Deaths, names.arg = covid_co_f$Age.group, 
        las=2, 
        main="Deaths By Age Group")
dev.off()
```

Here's the plot we just created:

```{r}
covid_co_f <- covid[(covid$State == "Colorado") & (covid$Sex == "Female"),]
par(mar = c(9, 4, 2, 2))
barplot(covid_co_f$COVID.19.Deaths, names.arg = covid_co_f$Age.group, 
        las=2, 
        main="Deaths By Age Group")
```

Note that three age groups have more than 0 but less than 9 cases, so the counts have been omitted from the data set to maintain confidentiality of the victims.

Let's repeat this process for two other states:
```{r, eval=F}
# deaths by age group for females in Wyoming
covid_wy_f <- covid[(covid$State == "Wyoming") & (covid$Sex == "Female"),]
png("output/covid_deaths_by_agegroup_wyoming_female.png")
par(mar = c(9, 4, 2, 2))
barplot(covid_wy_f$COVID.19.Deaths, names.arg = covid_wy_f$Age.group, 
        las=2, 
        main="Deaths By Age Group")
dev.off()


# deaths by age group for females in Wyoming
covid_nm_f <- covid[(covid$State == "New Mexico") & (covid$Sex == "Female"),]
png("output/covid_deaths_by_agegroup_newmexico_female.png")
par(mar = c(9, 4, 2, 2))
barplot(covid_nm_f$COVID.19.Deaths, names.arg = covid_nm_f$Age.group, 
        las=2, 
        main="Deaths By Age Group")
dev.off()
```

Here are these plots, too:

```{r, echo=F}
covid_wy_f <- covid[(covid$State == "Wyoming") & (covid$Sex == "Female"),]
par(mar = c(9, 4, 2, 2))
barplot(covid_wy_f$COVID.19.Deaths, names.arg = covid_wy_f$Age.group, 
        las=2, 
        main="Deaths By Age Group")
```

```{r, echo=F}
covid_nm_f <- covid[(covid$State == "New Mexico") & (covid$Sex == "Female"),]
par(mar = c(9, 4, 2, 2))
barplot(covid_nm_f$COVID.19.Deaths, names.arg = covid_nm_f$Age.group, 
        las=2, 
        main="Deaths By Age Group")
```
Now, if we wanted to do this for all States, this would take a lot of code.
But notice that the code we wrote in each case was very similar?
This is a perfect opportunity to use _looping_.
Looping involves running the same R commands multiple times, usually making small changes in between. 
The most common form of loop is called a _for-loop_.
Here's a simple example:

```{r}
vec <- c("a", "b", "c")  # create a vector
for(i in vec){   # loop through the elements of the vector
  print(i)           # print out the current element
}                    # stop the loop
```

This for-loop printed out each element of the `vec` variable, one at a time.
Here's the way this works:

- `for` tells R we want to repeat code multiple times. When R "sees" the `for` command, it knows that the code that follows will be repeated
- the parentheses (`(` and `)`) specify a vector that will be looped over (`vec` in this example), and a variable name to use while looping (`i` in this example). Each time through the loop, the variable (`i`) will have a different value. In this example, the __first__ time through the loop, `i` will have the value of the __first__ element of `vec` (`"a"`), the __second__ time through the loop, `i` will have the value of the __second__ element of `vec (`"b"`), etc. The name _for-loop_ is common in many programming languages, which reflects the fact that R is running the loop _for each_ element of the vector.
- The braces (`{` and `}`) specify which code should be run each time through the loop. In this example, we're just printing out the value of `i`, so the result is that each element of vec is printed in order. Recall that braces are a way of specifying a block of code, and R knows that everything inside the block should be run while looping.
- After it finishes looping, R continues proceeds to run any code below the for-loop.

Here's another example of a for-loop:

```{r}
for(j in 1:10){
  print(j^2)
}
print(j+1)
```

There are a few things to learn from this second example:

- The variable used in the loop doesn't have to be `i`. It can be any name you like.
- You can create vectors in the for-loop. Here we use `1:10` to generate a sequence of numbers from 1 to 10 (remember this?)
- The value of `j` (or whatever your looping variable is called) still exists after the for-loop is over. Here the _last_ value of `j` was 10, so printing `j+1` produced 11.

```{block2, type="caution"}
Don't forget to include the curly braces (`{`, `}`) after your for-loop, or else R may not include
```

```{block2, type="bonus"}
In some languages, white space like tabs and spaces are _significant_, meaning they imply something about what should happen when the code is run.
In R, spaces and tabs don't change anything about how code is run, and usually are used to make code more readable. 
For example, it's common to indent for-loops, for clarity, but it's not strictly necessary for the code to run.
This is another example of coding _style_.
```

```{block2, type="bonus"}
Technically, you don't _need_ to include braces after the for-loop, but if you leave them out, then R will only run the first command it finds after the `for(...)`.
```

Now let's gradually change the first example into a loop that runs visualizations for each state in our data set. 
First, instead of looping over `c("a", "b", "c")`, let's loop over state names:

```{r}
for(i in c("Colorado", "Wyoming", "New Mexico")){
  print(i)
}
```
Now instead of just printing the state name, let's create a data frame of just that state, for females:
```{r}
for(i in c("Colorado", "Wyoming", "New Mexico")){
  covid_state_f <- covid[(covid$State == i) & (covid$Sex == "Female"),]
}
```

Remember, each time through the loop, the value of `i` matches one of the state names in the vector.
So `covid$State == i` will produce a logical vector which is true for the rows specific to whichever state name we're on.
Notice that each time through the loop, the `covid_state_f` data frame will _also_ change, containing only the rows for the state we're on.
Now that we are selecting only the state of interest, let's produce a bar plot of cases, split by age group:

```{r}
# Loop though three states
for(i in c("Colorado", "Wyoming", "New Mexico")){
  # select only the rows from the state
  covid_state_f <- covid[(covid$State == i) & (covid$Sex == "Female"),]
  # create the file name using the state's name
  file_name <- paste("output/covid_deaths_by_agegroup_", i, "_female.png", sep="")
  # produce the plot
  png(file_name)
  par(mar = c(9, 4, 2, 2))
  barplot(covid_state_f$COVID.19.Deaths, names.arg = covid_nm_f$Age.group, 
          las=2, 
          main=paste("Deaths By Age Group, ", i, sep=""))
  dev.off()
}
```

We've used the `paste` function a few times in this loop, remember that it combines multiple strings using a separator, which we've set as an empty string (so no separator between the strings being combined).

```{block, type="caution"}
This is some of the most long and complex code that we've discussed so far! It's important that you fully understand what each line is doing, so take your time and review the above code chunk until you're comfortable with it.
```

Here comes the real power of this method. So far, we've just produced plots for three states, but with one small change, we can produce plots for each state in the data frame:

```{r}
for(i in unique(covid$State)){  # <<------ Here's the one change we made!
  covid_state_f <- covid[(covid$State == i) & (covid$Sex == "Female"),]
  file_name <- paste("output/covid_deaths_by_agegroup_", i, "_female.png", sep="")
  png(file_name)
  par(mar = c(9, 4, 2, 2))
  barplot(covid_state_f$COVID.19.Deaths, names.arg = covid_nm_f$Age.group, 
          las=2, 
          main=paste("Deaths By Age Group, ", i, sep=""))
  dev.off()
}
```

This code will now loop through _every unique value_ in the `State` column and produce identical visualizations for each state!

```{block, type="progress"}
Write a for-loop which loops through each age group category, and prints the total number of COVID-19 deaths across all states (Hint: each time through the loop, subset based on the age group, then find the sum of the deaths column, then print the result).
```


```{block, type="bonus"}
R has other functions for looping as well, but for-loops are _by far_ the most common.
Another option is `while` which, rather than looping through a vector, just continues looping forever as long as some condition is true. Try `?Control` for more info.
```

#### Nested Loops

Sometimes it becomes necessary to loop over multiple vectors at once.
This is possible by _nesting_ the for loops (putting one inside the other) like so:

```{r}
for(i in c(10, 50)){
  for(j in c(1, 2)){
    print(i + j)
  }
}
```

Look carefully at the output, and notice that `j` is changing "faster" than `i`: First `i` is 10, and `j` cycles through 1 and 2, then `i` is 50, and `j` cycles through 1 and 2 again.

```{block, type="caution"}
Notice that when nesting for-loops, each for loop has its own set of braces (`{`, `}`). Don't forget to put the second ending brace `}`! 
Another reason to use indenting is to catch mistakes like a missing ending brace.
```

Let's apply this concept to our COVID-19 data. 
So far, we've been generating plots for the females only, but we can include another loop which cycles through each Sex for each state (changes marked with comments):

```{r}
for(i in unique(covid$State)){  
  for(j in unique(covid$Sex)){  # add a nested loop for sex
    covid_state_sex <- covid[(covid$State == i) & (covid$Sex == j),]  # compare covid$Sex to j
    # add j to the file name
    file_name <- paste("output/covid_deaths_by_agegroup_", i, "_", j, ".png", sep="")
    png(file_name)
    par(mar = c(9, 4, 2, 2))
    barplot(covid_state_f$COVID.19.Deaths, names.arg = covid_nm_f$Age.group, 
            las=2, 
            main=paste("Deaths By Age Group,", i, j))  # change add Sex to title
    dev.off()
  }
}
```



```{block, type="caution"}
Nested for-loops can be useful and even necessary, but nesting can sometimes take a very long time to run. 
If two nested for loops each run through 1,000 vector elements, that means a total of 1,000,000 iterations through the inner loop's code!
It's possible to have a set of three nested for-loops or even more, but generally this is not wise practice, and in most cases there is a way to accomplish the same goal without so much much looping.
```

#### Breaking Out of For Loops.

Sometimes it's necessary to stop a loop earlier than expected.
This can be done with `break`, but this is best explained after discussing if/else statements.


### If Statements

So far, you've seen how to control the _flow_ of a program by having R run the same chunk of code multiple times. 
Another common way of controlling flow is to change the code that runs based on some condition. 
Let's return to the COVID example for a motivation.

Suppose we wanted to create a visualization of the data in each column of the data frame. 
Remember that the choice of visualization is affected by the type of variable being visualized (quantitative or categorical).
If the column is quantitative, we'd like to produce a histogram, perhaps, and if the column is categorical, we'd like to produce a bar graph.
Remember that looping runs the _same_ code each time through the loop, so how are we supposed to change the plot method to suit the variable type?
The answer is to use _if_ statements.

Before going further, here's a quick example:

```{r}
if("cat" == "dog"){
  print("Something doesn't make sense!")
}
```

This code produces precisely _no output_.
Even though there is a print command, R does not print anything!
The reason is that the print command is inside of an _if_ statement, and R only runs that code if the specified condition is met.
here's how it works:

- The `if` indicates the start of the if statement.
- R expects the parentheses to contain a logical statement that produces either `TRUE` or `FALSE`. In this example, we are comparing the character strings `"cat"` and `"dog"` (which are not the same, so the result is `FALSE`).
- If the condition is `TRUE`, then the code block in curly braces is run (not true for this example).
- If the condition is `FALSE`, then the code block is _not_ run. In the example (which is why this example did not print).
- Whether the code block is run or not, R will then proceed to run any code below the if statement.

```{block, type="caution"}
In the simple example above, the logical condition (`"cat" == "dog"`) is obviously false, so every time we run the code, the print statement will not be run. 
If the code never runs, then why go through the trouble of _including_ it?
The answer is that this simple example isn't realistic, and you should look at the next example.
```

Let's see how if statements can be used inside of a for loop.

```{r}
for(i in 1:5){
  if(i == 4){
    print(i)
  }
}
```
Here we have a for-loop which loops through the vector `1:5`, remember that the value of `i` is changing each time through the loop to a different element of the vector.
Each time through the loop, R evaluates the condition `i == 4`. 
If it is true, then the value of `i` is printed, otherwise nothing happens, because there is no other code in the for loop.
`i` takes on the value 4 exactly once, in which case the print statement runs and we see the value of `i`.
To summarize, the for-loop code ran five times, four of these times the if condition was `FALSE` and nothing happened, but one time the if condition was `TRUE`.


#### Else 

If statements can also be written with an `else` block, which specifies code to run if the logical condition is `FALSE`:

```{r}
for(i in 1:5){
  if(i == 4){  # condition to test
    print(i)   # code to run if condition is TRUE
  } else {
    print("Not 4")  # code to run if condition is FALSE
  }
}
```
Here you can see that rather than doing nothing when the condition is not true, the second code block (after `else`) is run instead.

Returning to the COVID example, let's loop through each of the columns of the data frame, and use an if statement to determine if it is a character or numeric mode (remember mode?).
Then let's choose an appropriate visualization based on the mode:

```{r, fig.height=3}
for(col_name in names(covid)){
  col <- covid[[col_name]]
  if(mode(col) == "numeric"){           # check if mode is numeric
    hist(col, main=col_name)            # plot histogram
  } else {                              # not numeric, assume character
    barplot(table(col), main=col_name)  # plot barplot
  }
}
```

Admittedly, these plots are a little crude, but the points is that the code is able to create the appropriate plot depending on the type of variable.
This is another way in which you can control the flow of an R program.

```{block, type="progress"}
Looking at visualizations like this for variables in a data set can be a useful way to identify potential problems. 
Look at the barplot for `State`, and notice that one category has more observations that the others. 
Which state this is (hint: the `table` and `sort` functions might be useful)? 
Create a new data frame by subsetting on the outlier state, and examine it.
Is there cause for concern? Why or why not?
```



```{block, type="bonus"}
There are other variations on if statements, including using `else if` to test a second condition if the first is not met, and the `switch` function which matches an argument to one of several possibilities, and runs different code for each match.
These are more advanced topics that will not be covered here.
```

```{block2, type="progress"}
Create a for-loop which loops through each state. 
In the for loop, determine whether there are more male or female deaths in the 45-54 age group. 
If there are more females, print "There are more female deaths in \<State\>", where \<State\> is the state name for that iteration in the loop. 
If there are more males or the deaths are the same, the print "There are not more female deaths in \<State\>".
```


#### Breaking Out of For Loops.

Sometimes it's useful to be able to stop a for-loop before it has finished looping through the whole vector.
This can be done with the `break` statement, which is usually placed within an if statement. 
Here's an example:

```{r}
for(i in 1:10){
  if(i == 6){
    break
  }
  print(i)
}
```
The if condition is `FALSE` at first, until `i` is 6, at which point the if condition is `TRUE`, so the `break` statement is run, and R exits from the loop, and doesn't loop through the rest of the vector.
Hence we see the numbers 1-5 printed but not the numbers 6-10.


### Formatting Conventions

Since R is a programming language, it is not immune to the common debates between programers regarding proper formatting.
For example, the following for-loops are all equivalent:

```{r}
for(i in 1:3){
  print(i)
}
```

```{r}
for(i in 1:3)
{
  print(i)
}
```

```{r}
for(i in 1:3) {print(i)}
```

```{r}
for(i in 1:3) print(i)
```

But different programmers (and sometimes programming communities) will have different ideas on what is best.
For this book, we'll use the first convention, but you could reasonably choose the second as well.
The third and fourth conventions should probably only be used if the code block is very short (e.g. a single command).
Mainly we raise these differences because you may have to read code written by someone with a different convention as yourself.


```{block, type='feedback'}
Any feedback for this section? Click [here](https://docs.google.com/forms/d/e/1FAIpQLSePQZ3lIaCIPo9J2owXImHZ_9wBEgTo21A0s-A1ty28u4yfvw/viewform?entry.1684471501=Basic%20Control%20Flow)
``` 

## Writing Functions

Throughout this course, we've been using various R _functions_, like `print`, `sum`, `is.na`, and `hist`. 
Each of these functions does different things, but they all obey similar rules.
First we'll think carefully about what all R functions have in common, then we'll see how you can write your own functions to suit your needs!

### The Components Of A Function

As an example, consider the `sum` function:

```{r}
v <- c(1, 2, 3)
sum(v)
```
When R runs this function, it takes a numeric vector and computes the sum of its elements.
The numeric vector is specified by _you_, the programmer, and it's formally called an _argument_.
The argument can be thought of as the "input" into the function.
Some functions use more than one argument, like the `seq` function:

```{r}
# Create a sequence of numbers from 3 to 9 
seq(3, 9)
```
while others functions might have _no_ arguments, like `getwd`:

```{r}
# Get the current working directory
getwd()
```
Other functions can work with different numbers of arguments, like the combine function, `c`:

```{r}
c(1)
```
```{r}
c(1,2)
```
```{r}
c(1,2,3)
```
Thinking back to the `sum` example, we also notice that the function produces a result, which is the sum of the elements of the vector.
This result is called a _return value_, because it's something that the function "returns" back to you after it has finished running.
Return values can assigned to R objects:

```{r}
s <- sum(v)
print(s)
```

The combine function's output is a vector, which we can assign to an object called `w`:
```{r}
# the return value of c() is assigned to w
w <- c("a", "b", "c") 
print(w)
```

Sometimes a function doesn't have a return value, as with the `rm` function:

```{r}
# rm doesn't have a return value, which is why result is NULL (i.e. no object)
result <- rm(w) 
print(result)
```
```{block, type="reflect"}
Remember what the `rm` function does?
```

Aside from the _arguments_ and the _return value_ of a function, we can talk about what the function actually _does_.
The `sum` function obviously computes the sum of a vector, but the `sqrt` takes the square root of a number:

```{r}
sqrt(58)
```
As we will see shortly, what a function _does_ is determined by the code in its _body_.
That's right, functions are basically a collection of code that is combined in a convenient package.
We can even examine the code for a function by typing its name _without parentheses_. 
Here's the `sort` function:

```{r}
# View the code of the sort function
sort
```
Now, there are some things in this output that may be confusing and that we won't explain in this book, but at least some of the output should look like R code to you!
Here's another example, the `mean` function:

```{r}
# View the code of the mean function (or so we think)
mean
```
This example doesn't seem to have as much R code in it, so where is the code for this function?
The answer is that both `sort` and `mean` (and many other R functions) are written in a _different_ programming language, C, which isn't human readable once it's compiled.
Don't worry too much about this, except that we will use the same method to view the code of our own functions later.

```{block, type="bonus"}
The way we've described R functions as being _arguments_, a _body_, and a _return value_, is mostly correct, but there is also something called the _environment_ of the function, which is essentially _scoping_, if you are familiar with that concept from other programming languages. 
We will discuss scoping briefly here but not in detail. 
For more on functions, check out [this link](http://adv-r.had.co.nz/Functions.html).
```

### Writing A Function

The beauty of functions in R is that you can write your own! 
All you have to do is specify the arguments, body, and return value for your function.
Here's a simple example how to define a function:

```{r}
# Create function which adds 1 to the input argument
add_one <- function(x){
  y <- x + 1
  return(y)
}
# test out the function
add_one(100)
```
Here we define a function called `add_one`, using the assignment operator `<-`, just like when we define new vectors, data frames, integers, etc.

- The statement `function` signifies that we are defining a new function, and the parentheses surround any arguments that this function accepts. Here, we have just one argument called `x`.
- The body of the code has just two commands. The first command creates a new variable `y` by adding 1 to the argument `x`. The second command specifies that `y` will be the return value of the function.
- The function is used by writing its name `add_one` and specifying the arguments in parentheses (100). Technically we are specifying that the value of `x` is 100.
- When the function is run, we see the return value (100 + 1) displayed in the output. 

Let's view the code of the function we just wrote:

```{r}
add_one
```
Here it shows us exactly the code that we used to create the function.
Let's use the function a few more times:

```{r}
number <- add_one(10)  # assign the return value of add_one to `number`
number
```
```{r}
# nest our function
add_one(add_one(add_one(1)))
```
```{block, type="caution"}
It's possible re-define the built in R functions by choosing a function name that already exists (`print` for example), but this is a _very bad idea_. This can make your code very difficult to understand, and potentially unpredictable!
```

Sometimes it's not necessary to specify a return value.
If you don't, then R will take any output generated by the last command in the function and return it:

```{r}
add_two <- function(x){
  x + 2  # R will return the result of x + 2 
}

add_two(12)
```

But you must be careful, because some commands produce no output. Remember that if we type math, then R will print the result:

```{r}
1 + 1
```
but if we assign the result to a variable, R will not print anything (the result is assigned to the variable instead):

```{r}
two <- 1 + 1
```

This is how it works for function return values as well. 
So if we write a statement at the end of a function, but assign the result to a variable, R will not return the value.

```{r}
add_three <- function(x){
  y <- x + 3  # the results are assigned to y, but y is not returned
}

add_three(4)  # this returns nothing
```

```{block2, type="bonus"}
This is technically _not true_. The above function _does_ return the value of y, but it is "invisible". To display the output, you can wrap the result in parentheses like this: `(add_three(4))`
```


Now let's look at a more complicated example that has two arguments:

```{r}
# function to raise x to the y-th power 
pow <- function(x, y){   # Here we specify the function has two arguments.
  p <- x^y
  return(p)
}
# test the arguments with x=2 and y=3
pow(2, 3)
```
There's an important lesson to learn from this example.
When we tested the function, R used 2 as the value of `x` and 3 for the value of `y` (after all, 2 cubed is 8), and this is because of the _order_ that the arguments were supplied. 
When we defined the function, we specified that `x` and `y` are the arguments, in that order.
Then when we called the function, we put 2 first and 3 second.
Perhaps this is obvious, but strange things are possible, because R also allows you to specify the arguments _by name_ like so:

```{r}
pow(x=2, y=3)
```
So far this gives the same result, but watch what happens if we do this instead:

```{r}
pow(y=2, x=3)
```
This time, R computed 3 squared instead of 2 cubed, even though we specified `y` first and `x` second.
When you specify parameters by name, _R will ignore the order that they are given in_.

```{block, type="bonus"}
R also allows you to specify some arguments by name and some by position, as long as the position arguments come first. 
For more, see [here](http://adv-r.had.co.nz/Functions.html).
```

```{block, type="progress"}
(No need to turn this in)
Write a function called `math` which has three arguments, a, b, and c.
In the body of the function, write code which computes a - b * c, store the result as x, then specify the return value of the function to be x.
Demonstrate the use of your function with a few examples. 
```


### Using Functions for Data Analysis

Functions offer many of the same advantages as loops: They allow you can write less code and do more.
Let's see how loops might be used for data analysis.  
Suppose we want to compare deaths between men and women for particular states and age groups. 
Here's a barplot for Colorado in the 45-54 age group: 

```{r, fig.width=6, fig.height=7}
# Extract just the state and age group of interest
covid2 <- covid[(covid$State == "Colorado") & (covid$Age.group == "45-54 years"),]

# create a bar plot
barplot(covid2$COVID.19.Deaths,  # specify column to plot
        names.arg=covid2$Sex,    # specify bar names
        main="Sex Comparison: Colorado 45-54 years",  # title
        ylab="COVID-19 Deaths")  # y label

```

Suppose we wanted to view this information for more states and age groups.
Rather than repeat the above code each time, let's put it in a function:

```{r, include=FALSE}
# create a function called plot_fm with two arguments: state and ages
plot_fm <- function(state, ages){
  covid2 <- covid[(covid$State == state) & (covid$Age.group == ages),]
  # set the maximum y limit manually, in case there are NA values
  ymax = max(covid2$COVID.19.Deaths, na.rm=T)
  if(ymax == -Inf) ymax <- 1
  # create the plot
  barplot(covid2$COVID.19.Deaths, 
          names.arg=covid2$Sex, 
          main=paste("Sex Comparison:", state, ages), 
          ylab="COVID-19 Deaths",
          ylim=c(0, ymax))
  return(NULL)
}
```
```{r}
# create a function called plot_fm with two arguments: state and ages
plot_fm <- function(state, ages){
  covid2 <- covid[(covid$State == state) & (covid$Age.group == ages),]
  barplot(covid2$COVID.19.Deaths, 
          names.arg=covid2$Sex, 
          main=paste("Sex Comparison:", state, ages), 
          ylab="COVID-19 Deaths")
  return(NULL)
}
```

Now let's try out the code on a few states and age groups:

```{r, fig.width=6, fig.height=7}
plot_fm("Colorado", "45-54 years")
```
```{r, fig.width=6, fig.height=7}
plot_fm("Texas", "65-74 years")
```
```{r, fig.width=6, fig.height=7}
plot_fm("New York", "85 years and over")
```


```{block, type="bonus"}
Notice that our function doesn't actually _return_ anything, but it does produce a plot while running.
The plots produced by this function are one example of _side effects_, which are changes that persist after the function is completed, that aren't the return value.
```

```{block2, type="bonus"}
If you tried to run `plot_fm("Colorado", "5-14 years")`, R would produce an error. 
This is because both the `COVID.19.Deaths` column for that State/Age group is `NA`, and R needs at least one non-`NA` value to determine the limits of the y axis. 
To get around this error, we could write extra code to manually set the y limits and specify them while plotting, like so:

  `covid2 <- covid[(covid$State == state) & (covid$Age.group == ages),]`

  `# set the maximum y limit manually, in case there are NA values`
  
  `ymax = max(covid2$COVID.19.Deaths, na.rm=T)`
  
  `if(ymax == -Inf) ymax <- 1`
  
  `# create the plot`
  
  `barplot(covid2$COVID.19.Deaths, `
  
  `        names.arg=covid2$Sex, `
  
  `        main=paste("Sex Comparison:", state, ages), `
  
  `        ylab="COVID-19 Deaths",`
  
  `        ylim=c(0, ymax))`
  
  `return(NULL)`

```

```{block, type="progress"}
(No need to turn this in)
Make a function with arguments for state, sex, and age group, and print out the COVID 19 deaths, Total Deaths, Pneumonia Deaths, and Influenza Deaths for that demographic.
```

### Function Scope

There's another important concept for functions in R, called _scope_, which is best illustrated through the following example:

```{r, error=TRUE}
simple_f <- function(){
  XYZ <- 2
  return(XYZ)
}

print(simple_f())
print(XYZ)

```

This function has no arguments, but it does create a new object called `var`, which is returned from the function.
Notice, however, that printing out `var` gives an error.
This is because the object `var` only exists in the _scope_ of the function `simple_f`, and is "forgotten" after the function finishes running.
This is true for any objects created inside any function (with one exception, noted in the bonus block below).
Variables defined outside of functions are in the _global scope_, which means they can be accessed anywhere, both inside and outside functions:

```{r}
y <- "hello"

say_hello <- function(){
  print(y)
}

say_hello()
```

It's also important to realize that variables in different scopes can have the same name without conflict. 
For example, we can use `x` as the argument to a function and as a variable outside of the function.
R will search the current scope first, then look outside of the current scope if it can't find an object.

```{r}

# define x and y in the global scope
x <- "a"
y <- "b"

f <- function(x){
  print(x)  # This is NOT the global x
  print(y)  # There's no y in the function scope, this is the global y
}

f("c")
```
In the above example, `x` was defined inside the function `f` (it's the name of the first argument), so the global `x` is ignored.
However, `y` is not defined inside the function, so R uses the `y` from the global scope.


```{block, type="bonus"}
In an earlier chapter, we briefly mentioned the assignment operators `<<-` and `->>`, but didn't say what made them special. 
It turns out, they are able to assign objects in the global scope from inside functions. 
You can test this by altering the above example by replacing the command `z <- 2` with the command `z <<- 2` and observing the result.
This assignment operator should almost _never_ be used, as it can cause confusion and unpredictable behavior if used in a more complicated R program.
```

```{block, type ="caution"}
When writing functions, it helps to start simple. It's easy to make a complicated function, but when you try to put it into use and it doesn't work, debugging the issue can be equally complicated.
```

```{block, type="bonus"}
You may be familiar with "pointers" in other language, and the difference between "pass by value" and "pass by reference". 
In most ordinary circumstances with R, there is _only_ pass by value.
```

```{block, type="progress"}
(No need to turn this in)
When discussing Objects in a previous chapter, we mentioned that everything in R is an object, and every object has a `mode` and `length`.
pick an R function, or create your own function, and print its `mode` and `length`.
```

```{block, type='feedback'}
Any feedback for this section? Click [here](https://docs.google.com/forms/d/e/1FAIpQLSePQZ3lIaCIPo9J2owXImHZ_9wBEgTo21A0s-A1ty28u4yfvw/viewform?entry.1684471501=Writing%20Functions)
``` 


## Advanced Control Flow

In this section, we'll discuss more ways to control the flow of your code. 
Specifically, we'll talk about the `apply` family of functions, starting with `sapply`.
To show what `sapply` does, let's look at the following function:

```{r}
square_plus_one <- function(x){
  return(x^2 + 1)
}
```

This function returns the result of squaring the input argument and adding 1.
Suppose we wanted to run this function to every element of a vector.
One option would be to write a for-loop:

```{r}
# the function we want to apply our function to
x <- 1:10

# create an empty vector to hold the result
y <- numeric(10)

# loop through x and apply the function
for(i in 1:10){
  y[i] <- square_plus_one(x[i]) 
}

y
```

Here's another way to do the same thing using the `sapply` function:


```{r}
# apply the function square_plus_one to every 
z <- sapply(x, square_plus_one)

# z agrees with y!
print(z == y)

# z is a vector
mode(z)
```
In words, the `sapply` function says "loop through every element of this vector, and apply this function to it."
All you have to specify is which vector to loop through, and which function to apply.
The "s" in `sapply` stands for "simplify", meaning the result will be simplified to a vector, matrix, or higher dimensional array.
In some cases, you may want the result to be returned as a list, instead of a vector. In this case, the `lapply` function can be used:

```{r}
# apply the function square_plus_one to every 
w <- lapply(x, square_plus_one)

# w is a list
mode(w)
```

`lapply` and `sapply` can also be used if the function doesn't always return the same type or length of data. Here's an example:

```{r}
make_vector <- function(n){
  # make a vector of length n numbered from 1 to n
  1:n
}

# apply make_vector to each element of x:
x <- c(2, 2, 3, 1, 6)
lapply(x, make_vector)
```
The differences between `lapply` and `sapply` (and other functions in the apply family) can be subtle and very confusing at times, even after reading the documentation using `?lapply`, but here is one way they are different:

```{r}
x <- list(1, 2, 3)

l <- lapply(x, square_plus_one)
print(mode(l))

s <- sapply(x, square_plus_one)
print(mode(s))
```

The input `x` started as a list, so the default return of `lapply` is a list.
However, `sapply` simplified the result to a vector.
If you know the type of data that will be returned, you can use the `vapply` function, which can be faster than `sapply` in some cases.

```{r}
ch <- vapply(x, square_plus_one, 1)
```

Here we've supplied an extra argument (`1`) to tell R that the elements will be numeric types.

```{block, type="caution"}
The differences between `lapply`, `sapply`, and `vapply` are not easy to understand, especially because they give the same results sometimes.
A simple yet imperfect rule is that `sapply` will work in most cases, but you can use `lapply` if you don't want lists to be simplified, and use `vapply` if you know what type the result will be.
```

### Applying Over Multiple Dimensions

Suppose we want to find the variance of each row of a matrix. 
The `lapply` or `sapply` only work on each _element_ of a matrix, not each row.
For this, we need the `apply` function:

```{r}
m <- matrix(c(1, 1, 1, 1, 2, 3, 2, 4, 6), 3, 3, byrow=T)

apply(m, 1, var)
```
The arguments to this function are:

- `m`: The matrix to be iterated over
- `1`: The axis to iterate over
- `var`: The function to apply over the axis

### Applying Over Data Frame Groups

Lastly, we'll show how you can apply a function to each group specified by a grouping variable. 
Suppose we wanted to add the COVID deaths across all Age groups for _each state_.
Then we could use the `tapply` function, with `COVID.19.Deaths` as the vector to iterate over, `State` as the grouping variable, and `sum` as the function to use. 
Here's the result:

```{r}
state_deaths <- tapply(covid$COVID.19.Deaths, covid$State, sum, na.rm=T)
sort(state_deaths)
```
Here we also had to specify the `na.rm=T` parameter so that `NA` values are removed when computing the sum.
Remember that these totals may not match the `All Ages` number from each state, because some counts are suppressed.
Here's another example where we sum the deaths across all states for _each Age group_ 

```{r}
# remove US total numbers first
covid <- covid[covid$State != "United States",]

agegroup_deaths <- tapply(covid$COVID.19.Deaths, covid$Age.group, sum, na.rm=T)
sort(agegroup_deaths)
```

Remember that these totals may not match the `United States` values from the dataset because some counts are suppressed.


```{block, type='feedback'}
Any feedback for this section? Click [here](https://docs.google.com/forms/d/e/1FAIpQLSePQZ3lIaCIPo9J2owXImHZ_9wBEgTo21A0s-A1ty28u4yfvw/viewform?entry.1684471501=Advanced%20Control%20Flow)
``` 


## Working With Popular Packages

```{block, type="caution"}
This section is still under construction
```

[1] "R Packages"
```{block, type='feedback'}
Any feedback for this section? Click [here](https://docs.google.com/forms/d/e/1FAIpQLSePQZ3lIaCIPo9J2owXImHZ_9wBEgTo21A0s-A1ty28u4yfvw/viewform?entry.1684471501=R%20Packages)
``` 
